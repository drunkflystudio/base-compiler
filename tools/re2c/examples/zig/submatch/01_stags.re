// re2zig $INPUT -o $OUTPUT

const std = @import("std");

const SemVer = struct {
    major: u32,
    minor: u32,
    patch: u32,
};

const none = std.math.maxInt(usize);

fn s2n(str: []const u8) u32 { // convert a pre-parsed string to a number
    var n: u32 = 0;
    for (str) |c| { n = n * 10 + (c - 48); }
    return n;
}

fn parse(yyinput: [:0]const u8) ?SemVer {
    var yycursor: usize = 0;
    var yymarker: usize = 0;

    // Final tag variables available in semantic action.
    %{svars format = "var @@: usize = none;"; %}

    // Intermediate tag variables used by the lexer (must be autogenerated).
    %{stags format = "var @@: usize = none;"; %}

    %{
        re2c:yyfill:enable = 0;
        re2c:tags = 1;

        num = [0-9]+;

        @t1 num @t2 "." @t3 num @t4 ("." @t5 num)? [\x00] {
            return SemVer {
                .major = s2n(yyinput[t1..t2]),
                .minor = s2n(yyinput[t3..t4]),
                .patch = if (t5 == none) 0 else s2n(yyinput[t5..yycursor - 1]),
            };
        }
        * { return null; }
    %}
}

test {
    try std.testing.expectEqual(parse("23.34"), SemVer{.major = 23, .minor = 34, .patch = 0});
    try std.testing.expectEqual(parse("1.2.99999"), SemVer{.major = 1, .minor = 2, .patch = 99999});
    try std.testing.expectEqual(parse("1.a"), null);
}
