/* Generated by re2d */
// re2d $INPUT -o $OUTPUT -i --header lexer/state.d
module main;

import core.stdc.stddef;
import lexer.state; // the module is generated by re2c



private long lex(ref LexerState yyrecord) {
    const(char)* t;
    
{
    char yych;
    goto yy0;
yy1:
    ++yyrecord.yycursor;
yy0:
    yych = *yyrecord.yycursor;
    switch (yych) {
        case 'a': goto yy1;
        case 'b':
            yyrecord.yyt1 = yyrecord.yycursor;
            goto yy3;
        default:
            yyrecord.yyt1 = yyrecord.yycursor;
            goto yy2;
    }
yy2:
    t = yyrecord.yyt1;
    { return t - yyrecord.str; }
yy3:
    ++yyrecord.yycursor;
    yych = *yyrecord.yycursor;
    switch (yych) {
        case 'b': goto yy3;
        default: goto yy2;
    }
}

}

void main() {
    const(char)* s = "ab";
    LexerState st = {s, s , null};
    assert(lex(st) == 1);

    const(char)* s2 = "aaabbbbbbbb";
    LexerState st2 = {s2, s2 , null};
    assert(lex(st2) == 3);
}
/* Generated by re2d */

module lexer.state;

struct LexerState {
    const(char)* str, yycursor;
    const(char)* yyt1;
};
d/headers/header.re:25:21: warning: rule matches empty string [-Wmatch-empty-string]
