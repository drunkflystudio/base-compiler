-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
#1 "haskell/eof/04_fake_sentinel.re"
-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad (when)
import qualified Data.ByteString as BS

data State = State {
    _str :: BS.ByteString,
    _cur :: Int,
    _lim :: Int,
    _cnt :: Int
}

-- Expect a string without terminating null.

#21 "haskell/eof/04_fake_sentinel.hs"
yy0 :: State -> Int
yy0 State{..} =
    let yych = if _cur < _lim then BS.index _str _cur else 0 in
    let cur = _cur + 1 in let _cur = cur in
    case yych of
        _c | 0x00 == _c ->
            yy1 State{..}
        _c | 0x20 == _c ->
            yy3 State{..}
        _c | 0x61 <= _c && _c <= 0x7A ->
            yy5 State{..}
        _c | True ->
            yy2 State{..}

yy1 :: State -> Int
yy1 State{..} =
#24 "haskell/eof/04_fake_sentinel.re"
    _cnt
#40 "haskell/eof/04_fake_sentinel.hs"

yy2 :: State -> Int
yy2 State{..} =
#23 "haskell/eof/04_fake_sentinel.re"
    (-1)
#46 "haskell/eof/04_fake_sentinel.hs"

yy3 :: State -> Int
yy3 State{..} =
    let yych = if _cur < _lim then BS.index _str _cur else 0 in
    case yych of
        _c | 0x20 == _c ->
            let cur = _cur + 1 in let _cur = cur in
            yy3 State{..}
        _c | True ->
            yy4 State{..}

yy4 :: State -> Int
yy4 State{..} =
#26 "haskell/eof/04_fake_sentinel.re"
    lexer State{..}
#62 "haskell/eof/04_fake_sentinel.hs"

yy5 :: State -> Int
yy5 State{..} =
    let yych = if _cur < _lim then BS.index _str _cur else 0 in
    case yych of
        _c | 0x61 <= _c && _c <= 0x7A ->
            let cur = _cur + 1 in let _cur = cur in
            yy5 State{..}
        _c | True ->
            yy6 State{..}

yy6 :: State -> Int
yy6 State{..} =
#25 "haskell/eof/04_fake_sentinel.re"
    lexer State{_cnt = _cnt + 1, ..}
#78 "haskell/eof/04_fake_sentinel.hs"

lexer :: State -> Int
lexer State{..} =
    yy0 State{..}

#27 "haskell/eof/04_fake_sentinel.re"


main :: IO ()
main = do
    let test s n =
            let st = State {_str = s, _cur = 0, _lim = BS.length s, _cnt = 0}
            in when (lexer st /= n) $ error "failed"

    test "" 0
    test "one two three " 3
    test "f0ur" (-1)
