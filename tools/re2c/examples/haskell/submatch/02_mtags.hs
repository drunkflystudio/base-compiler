-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
#1 "haskell/submatch/02_mtags.re"
-- re2hs $INPUT -o $OUTPUT
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad (when)
import Data.ByteString (ByteString, index)

data State = State {
    -- Final tag bindings available in semantic action.
    
#15 "haskell/submatch/02_mtags.hs"

_1 :: !Int,
_2 :: !Int,
#10 "haskell/submatch/02_mtags.re"

    
#22 "haskell/submatch/02_mtags.hs"

_3 :: ![Int],
_4 :: ![Int],
#11 "haskell/submatch/02_mtags.re"

    -- Intermediate tag bindings used by the lexer (must be autogenerated).
    
#30 "haskell/submatch/02_mtags.hs"

_yyt1 :: !Int,
_yyt2 :: !Int,
#13 "haskell/submatch/02_mtags.re"

    
#37 "haskell/submatch/02_mtags.hs"

_yytm3 :: ![Int],
_yytm4 :: ![Int],
#14 "haskell/submatch/02_mtags.re"

    _yyinput :: !ByteString,
    _yycursor :: !Int,
    _yymarker :: !Int
}

s2n :: ByteString -> Int -> Int -> Int
s2n s i j = f i 0 where
    f k n = if k >= j then n else f (k + 1) (n * 10 + (fromIntegral (index s k) - 48))


#53 "haskell/submatch/02_mtags.hs"
yy0 :: State -> Maybe [Int]
yy0 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let _yyt1 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy3 State{..}
        _c | True ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy1 State{..}

yy1 :: State -> Maybe [Int]
yy1 State{..} =
    yy2 State{..}

yy2 :: State -> Maybe [Int]
yy2 State{..} =
#36 "haskell/submatch/02_mtags.re"
    Nothing
#74 "haskell/submatch/02_mtags.hs"

yy3 :: State -> Maybe [Int]
yy3 State{..} =
    let _yymarker = _yycursor in
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _yyt2 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy4 State{..}
        _c | 0x2E == _c ->
            let _yyt2 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy7 State{..}
        _c | True ->
            yy2 State{..}

yy4 :: State -> Maybe [Int]
yy4 State{..} =
    let _1 = _yyt1 in
    let _2 = _yyt2 in
    let _3 = _yytm3 in
    let _4 = _yytm4 in
#33 "haskell/submatch/02_mtags.re"
    Just $ (s2n _yyinput _1 _2) : (reverse $ zipWith (\i j -> s2n _yyinput i j) _3 _4)
#105 "haskell/submatch/02_mtags.hs"

yy5 :: State -> Maybe [Int]
yy5 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            let tag = _yycursor : _yytm3 in let _yytm3 = tag in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy8 State{..}
        _c | True ->
            yy6 State{..}

yy6 :: State -> Maybe [Int]
yy6 State{..} =
    let _yycursor = _yymarker in
    yy2 State{..}

yy7 :: State -> Maybe [Int]
yy7 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x00 == _c ->
            
            
            let _yyt2 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy4 State{..}
        _c | 0x2E == _c ->
            let _yyt2 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy7 State{..}
        _c | True ->
            yy6 State{..}

yy8 :: State -> Maybe [Int]
yy8 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x00 == _c ->
            let tag = _yycursor : _yytm4 in let _yytm4 = tag in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy4 State{..}
        _c | 0x2E == _c ->
            let tag = _yycursor : _yytm4 in let _yytm4 = tag in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy5 State{..}
        _c | 0x30 <= _c && _c <= 0x39 ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy8 State{..}
        _c | True ->
            yy6 State{..}

parse :: State -> Maybe [Int]
parse State{..} =
    yy0 State{..}

#37 "haskell/submatch/02_mtags.re"


test :: ByteString -> Maybe [Int] -> IO ()
test str expect = do
    let st = State {
        
#172 "haskell/submatch/02_mtags.hs"

_1 = (-1),
_2 = (-1),
#42 "haskell/submatch/02_mtags.re"

        
#179 "haskell/submatch/02_mtags.hs"

_yyt1 = (-1),
_yyt2 = (-1),
#43 "haskell/submatch/02_mtags.re"

        
#186 "haskell/submatch/02_mtags.hs"

_3 = [],
_4 = [],
#44 "haskell/submatch/02_mtags.re"

        
#193 "haskell/submatch/02_mtags.hs"

_yytm3 = [],
_yytm4 = [],
#45 "haskell/submatch/02_mtags.re"

        _yyinput = str,
        _yycursor = 0,
        _yymarker = 0
    }
    when (parse st /= expect) $ error "failed!"

main :: IO ()
main = do
    test "1\0" (Just [1])
    test "1.2.3.4.5.6.7\0" (Just [1, 2, 3, 4, 5, 6, 7])
    test "1.2.\0" Nothing
