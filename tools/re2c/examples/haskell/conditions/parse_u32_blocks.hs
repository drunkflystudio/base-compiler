-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT -i
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad (when)
import Data.ByteString (ByteString, index)

data State = State {
    _yyinput :: !ByteString,
    _yycursor :: !Int,
    _yymarker :: !Int
}

peek_digit :: ByteString -> Int -> Int -> Int
peek_digit str idx offs = fromIntegral (index str (idx - 1)) - offs




yy0 :: State -> Int -> Int
yy0 State{..} num =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            yy2 State{..} num
        _c | True ->
            yy1 State{..} num

yy1 :: State -> Int -> Int
yy1 State{..} num =
    num

yy2 :: State -> Int -> Int
yy2 State{..} num =
    parse_bin State{..} $ num * 2 + (peek_digit _yyinput _yycursor 48)

parse_bin :: State -> Int -> Int
parse_bin State{..} num =
    yy0 State{..} num




yy3 :: State -> Int -> Int
yy3 State{..} num =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x30 <= _c && _c <= 0x37 ->
            yy5 State{..} num
        _c | True ->
            yy4 State{..} num

yy4 :: State -> Int -> Int
yy4 State{..} num =
    num

yy5 :: State -> Int -> Int
yy5 State{..} num =
    parse_oct State{..} $ num * 8 + (peek_digit _yyinput _yycursor 48)

parse_oct :: State -> Int -> Int
parse_oct State{..} num =
    yy3 State{..} num




yy6 :: State -> Int -> Int
yy6 State{..} num =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy8 State{..} num
        _c | True ->
            yy7 State{..} num

yy7 :: State -> Int -> Int
yy7 State{..} num =
    num

yy8 :: State -> Int -> Int
yy8 State{..} num =
    parse_dec State{..} $ num * 10 + (peek_digit _yyinput _yycursor 48)

parse_dec :: State -> Int -> Int
parse_dec State{..} num =
    yy6 State{..} num




yy9 :: State -> Int -> Int
yy9 State{..} num =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 ->
            yy11 State{..} num
        _c | 0x41 <= _c && _c <= 0x46 ->
            yy12 State{..} num
        _c | 0x61 <= _c && _c <= 0x66 ->
            yy13 State{..} num
        _c | True ->
            yy10 State{..} num

yy10 :: State -> Int -> Int
yy10 State{..} num =
    num

yy11 :: State -> Int -> Int
yy11 State{..} num =
    parse_hex State{..} $ num * 16 + (peek_digit _yyinput _yycursor 48)

yy12 :: State -> Int -> Int
yy12 State{..} num =
    parse_hex State{..} $ num * 16 + (peek_digit _yyinput _yycursor 55)

yy13 :: State -> Int -> Int
yy13 State{..} num =
    parse_hex State{..} $ num * 16 + (peek_digit _yyinput _yycursor 87)

parse_hex :: State -> Int -> Int
parse_hex State{..} num =
    yy9 State{..} num




yy14 :: State -> Maybe Int
yy14 State{..} =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x30 == _c ->
            yy16 State{..}
        _c | 0x31 <= _c && _c <= 0x39 ->
            yy18 State{..}
        _c | True ->
            yy15 State{..}

yy15 :: State -> Maybe Int
yy15 State{..} =
    Nothing

yy16 :: State -> Maybe Int
yy16 State{..} =
    let _yymarker = _yycursor in
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x42 == _c || 0x62 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy19 State{..}
        _c | 0x58 == _c || 0x78 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy21 State{..}
        _c | True ->
            yy17 State{..}

yy17 :: State -> Maybe Int
yy17 State{..} =
    Just $ parse_oct State{..} 0

yy18 :: State -> Maybe Int
yy18 State{..} =
    let __ = _yycursor - 1 in let _yycursor = __ in
    Just $ parse_dec State{..} 0

yy19 :: State -> Maybe Int
yy19 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x30 <= _c && _c <= 0x31 ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy22 State{..}
        _c | True ->
            yy20 State{..}

yy20 :: State -> Maybe Int
yy20 State{..} =
    let _yycursor = _yymarker in
    yy17 State{..}

yy21 :: State -> Maybe Int
yy21 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x30 <= _c && _c <= 0x39 || 0x41 <= _c && _c <= 0x46 || 0x61 <= _c && _c <= 0x66 ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy23 State{..}
        _c | True ->
            yy20 State{..}

yy22 :: State -> Maybe Int
yy22 State{..} =
    let __ = _yycursor - 1 in let _yycursor = __ in
    Just $ parse_bin State{..} 0

yy23 :: State -> Maybe Int
yy23 State{..} =
    let __ = _yycursor - 1 in let _yycursor = __ in
    Just $ parse_hex State{..} 0

parse :: State -> Maybe Int
parse State{..} =
    yy14 State{..}



test :: ByteString -> Maybe Int -> IO ()
test str expect = do
    let s = State {_yyinput = str, _yycursor = 0, _yymarker = 0}
    when (parse s /= expect) $ error "failed!"

main :: IO ()
main = do
    test "\0" Nothing
    test "1234567890\0" (Just 1234567890)
    test "0b1101\0" (Just 13)
    test "0x7Fe\0" (Just 2046)
    test "0644\0" (Just 420)
    test "9223372036854775807\0" (Just 9223372036854775807)
