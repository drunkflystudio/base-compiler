// Code generated by re2go, DO NOT EDIT.
//line "go/fill/01_fill.re":1
//go:generate re2go $INPUT -o $OUTPUT
package main

import (
	"os"
	"strings"
)

const BUFSIZE uint = 4096

type Input struct {
	file     *os.File
	yyinput  []byte
	yycursor uint
	yymarker uint
	yylimit  uint
	token    uint
	eof      bool
}

func fill(in *Input) int {
	if in.eof { return -1 } // unexpected EOF

	// Error: lexeme too long. In real life can reallocate a larger buffer.
	if in.token < 1 { return -2 }

	// Shift buffer contents (discard everything up to the current token).
	copy(in.yyinput[0:], in.yyinput[in.token:in.yylimit])
	in.yycursor -= in.token
	in.yymarker -= in.token
	in.yylimit -= in.token
	in.token = 0

	// Fill free space at the end of buffer with new data from file.
	n, _ := in.file.Read(in.yyinput[in.yylimit:BUFSIZE])
	in.yylimit += uint(n)
	in.yyinput[in.yylimit] = 0

	// If read less than expected, this is the end of input.
	in.eof = in.yylimit < BUFSIZE

	return 0
}

func lex(yyrecord *Input) int {
	count := 0
	for {
		yyrecord.token = yyrecord.yycursor
	
//line "go/fill/01_fill.go":53
{
	var yych byte
yyFillLabel0:
	yych = yyrecord.yyinput[yyrecord.yycursor]
	switch (yych) {
	case ' ':
		goto yy3
	case '\'':
		goto yy5
	default:
		if (yyrecord.yylimit <= yyrecord.yycursor) {
			if (fill(yyrecord) == 0) {
				goto yyFillLabel0
			}
			goto yy10
		}
		goto yy1
	}
yy1:
	yyrecord.yycursor += 1
yy2:
//line "go/fill/01_fill.re":57
	{ return -1 }
//line "go/fill/01_fill.go":77
yy3:
	yyrecord.yycursor += 1
yyFillLabel1:
	yych = yyrecord.yyinput[yyrecord.yycursor]
	switch (yych) {
	case ' ':
		goto yy3
	default:
		if (yyrecord.yylimit <= yyrecord.yycursor) {
			if (fill(yyrecord) == 0) {
				goto yyFillLabel1
			}
		}
		goto yy4
	}
yy4:
//line "go/fill/01_fill.re":60
	{ continue }
//line "go/fill/01_fill.go":96
yy5:
	yyrecord.yycursor += 1
	yyrecord.yymarker = yyrecord.yycursor
yyFillLabel2:
	yych = yyrecord.yyinput[yyrecord.yycursor]
	if (yych >= 0x01) {
		goto yy7
	}
	if (yyrecord.yylimit <= yyrecord.yycursor) {
		if (fill(yyrecord) == 0) {
			goto yyFillLabel2
		}
		goto yy2
	}
yy6:
	yyrecord.yycursor += 1
yyFillLabel3:
	yych = yyrecord.yyinput[yyrecord.yycursor]
yy7:
	switch (yych) {
	case '\'':
		goto yy8
	case '\\':
		goto yy9
	default:
		if (yyrecord.yylimit <= yyrecord.yycursor) {
			if (fill(yyrecord) == 0) {
				goto yyFillLabel3
			}
			goto yy11
		}
		goto yy6
	}
yy8:
	yyrecord.yycursor += 1
//line "go/fill/01_fill.re":59
	{ count += 1; continue }
//line "go/fill/01_fill.go":134
yy9:
	yyrecord.yycursor += 1
yyFillLabel4:
	yych = yyrecord.yyinput[yyrecord.yycursor]
	if (yych <= 0x00) {
		if (yyrecord.yylimit <= yyrecord.yycursor) {
			if (fill(yyrecord) == 0) {
				goto yyFillLabel4
			}
			goto yy11
		}
		goto yy6
	}
	goto yy6
yy10:
//line "go/fill/01_fill.re":58
	{ return count }
//line "go/fill/01_fill.go":152
yy11:
	yyrecord.yycursor = yyrecord.yymarker
	goto yy2
}
//line "go/fill/01_fill.re":61

	}
}

func main() () {
	fname := "input"
	content := "'qu\000tes' 'are' 'fine: \\'' ";

	// Prepare input file: a few times the size of the buffer, containing
	// strings with zeroes and escaped quotes.
	f, _ := os.Create(fname)
	f.WriteString(strings.Repeat(content, int(BUFSIZE)))
	f.Seek(0, 0)
	count := 3 * int(BUFSIZE) // number of quoted strings written to file

	// Prepare lexer state: all offsets are at the end of buffer.
	in := &Input{
		file:     f,
		// Sentinel at `yylimit` offset is set to zero, which triggers YYFILL.
		yyinput:  make([]byte, BUFSIZE+1),
		yycursor: BUFSIZE,
		yymarker: BUFSIZE,
		yylimit:  BUFSIZE,
		token:    BUFSIZE,
		eof:      false,
	}

	// Run the lexer.
	if lex(in) != count { panic("error"); }

	// Cleanup: remove input file.
	f.Close();
	os.Remove(fname);
}
