#include <drunkfly/compiler/codegen.h>
#include <drunkfly/compiler/arena.h>

STRUCT(Context) {
    Compiler* compiler;
};

static void translationUnitBegin(void* ud)
{
    UNUSED(ud);
}

static void translationUnitEnd(void* ud)
{
    UNUSED(ud);
}

static void attrBegin(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void attrParam(void* ud, const CompilerLocation* optionalNameLoc, const char* optionalName, CompilerExpr* value)
{
    UNUSED(ud);
    UNUSED(optionalNameLoc);
    UNUSED(optionalName);
    UNUSED(value);
}

static void attrEnd(void* ud)
{
    UNUSED(ud);
}

static void attrListBegin(void* ud)
{
    UNUSED(ud);
}

static void attrListEnd(void* ud)
{
    UNUSED(ud);
}

static void enumBegin(void* ud,
    const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name, bool isFlags)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
    UNUSED(isFlags);
}

static void enumType(void* ud, const CompilerLocation* loc, CompilerType* type)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(type);
}

static void enumMembersBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void enumMember(void* ud, const CompilerLocation* loc, const char* name, CompilerExpr* optionalValue)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(optionalValue);
}

static void enumMembersEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void enumEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void structBegin(void* ud,
    const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name, bool isUnion)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
    UNUSED(isUnion);
}

static void structParent(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void structMembersBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void structMember(void* ud, const CompilerLocation* loc, const char* name, CompilerType* type)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(type);
}

static void structMembersEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void structEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void classBegin(void* ud,
    const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name, bool isFinal)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
    UNUSED(isFinal);
}

static void classBeginInterface(void* ud,
    const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
}

static void classParent(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void classMembersBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void classFriend(void* ud, const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
}

static void classVariablesBegin(void* ud, const CompilerLocation* loc,
    const CompilerLocation* visLoc, CompilerVisibility vis, const CompilerLocation* optionalStatic, bool isConst)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(visLoc);
    UNUSED(vis);
    UNUSED(optionalStatic);
    UNUSED(isConst);
}

static void classVariablesEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void classDestructorBegin(void* ud,
    const CompilerLocation* loc, const char* name, const CompilerLocation* visLoc, CompilerVisibility vis)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(visLoc);
    UNUSED(vis);
}

static void classDestructorEnd(void* ud)
{
    UNUSED(ud);
}

static void classMethodBegin(void* ud, const CompilerLocation* loc, const CompilerLocation* visLoc,
    CompilerVisibility vis, const CompilerLocation* optionalStatic, const CompilerLocation* retLoc, CompilerType* ret)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(visLoc);
    UNUSED(vis);
    UNUSED(optionalStatic);
    UNUSED(retLoc);
    UNUSED(ret);
}

static void classMethodNameSimple(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void classMethodNameArg(void* ud, const CompilerLocation* loc,
    const char* name, CompilerType* type, const CompilerLocation* argLoc, const char* arg)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(type);
    UNUSED(argLoc);
    UNUSED(arg);
}

static void classMethodNameEnd(void* ud,
    const CompilerLocation* optionalFinal, const CompilerLocation* optionalOverride)
{
    UNUSED(ud);
    UNUSED(optionalFinal);
    UNUSED(optionalOverride);
}

static void classMethodEnd_Abstract(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void classMethodBodyBegin(void* ud)
{
    UNUSED(ud);
}

static void classMethodEnd(void* ud)
{
    UNUSED(ud);
}

static void classMembersEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void classEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void varDeclBegin(void* ud, const CompilerLocation* loc, const CompilerLocation* optionalStatic, bool isConst)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(optionalStatic);
    UNUSED(isConst);
}

static void varBegin(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void varType(void* ud, const CompilerLocation* loc, CompilerType* type)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(type);
}

static void varType_Array(void* ud, const CompilerLocation* loc, CompilerType* elementType, CompilerExpr* size)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(elementType);
    UNUSED(size);
}

static void varInitializer(void* ud, CompilerExpr* value)
{
    UNUSED(ud);
    UNUSED(value);
}

static void varEnd(void* ud)
{
    UNUSED(ud);
}

static void varDeclEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void structInitializerBegin(void* ud)
{
    UNUSED(ud);
}

static void structInitializer(void* ud, const CompilerLocation* loc, const char* name, CompilerExpr* value)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(value);
}

static void structInitializerEnd(void* ud)
{
    UNUSED(ud);
}

static void arrayInitializerBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void arrayInitializer(void* ud, CompilerExpr* value)
{
    UNUSED(ud);
    UNUSED(value);
}

static void arrayInitializerEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static CompilerType* typeVoid(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeBit(void* ud, const CompilerLocation* loc, CompilerExpr* optionalExpr)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(optionalExpr);
    return NULL;
}

static CompilerType* typeBool(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeInt8(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeUInt8(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeInt16(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeUInt16(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeInt32(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeUInt32(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeObject(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerType* typeIdentifier(void* ud, const CompilerLocation* loc, const char* text)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(text);
    return NULL;
}

static CompilerType* typePointer(void* ud, const CompilerLocation* loc, CompilerType* pointee)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(pointee);
    return NULL;
}

static CompilerExpr* exprNull(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerExpr* exprFalse(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerExpr* exprTrue(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerExpr* exprIdentifier(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    return NULL;
}

static CompilerExpr* exprInteger(void* ud, const CompilerLocation* loc, uint_value_t value)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(value);
    return NULL;
}

static CompilerExpr* exprParentheses(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static void exprNewBegin(void* ud, const CompilerLocation* loc, CompilerType* type)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(type);
}

static CompilerExpr* exprNewEnd_Struct(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerExpr* exprNewEnd_Array(void* ud, const CompilerLocation* loc, CompilerExpr* size)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(size);
    return NULL;
}

static void exprMethodCallBegin(void* ud, CompilerExpr* callee)
{
    UNUSED(ud);
    UNUSED(callee);
}

static void exprMethodSimple(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void exprMethodArg(void* ud, const CompilerLocation* loc, const char* name, CompilerExpr* value)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
    UNUSED(value);
}

static CompilerExpr* exprMethodCallEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
    return NULL;
}

static CompilerExpr* exprSubscript(void* ud, const CompilerLocation* loc, CompilerExpr* arr, CompilerExpr* idx)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(arr);
    UNUSED(idx);
    return NULL;
}

static CompilerExpr* exprMember(void* ud,
    const CompilerLocation* loc, CompilerExpr* target, const CompilerLocation* nameLoc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(target);
    UNUSED(nameLoc);
    UNUSED(name);
    return NULL;
}

static CompilerExpr* exprPostfixIncr(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprPostfixDecr(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprPrefixIncr(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprPrefixDecr(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprTakeAddress(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprDeref(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprUnaryPlus(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprUnaryMinus(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprBitwiseNot(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprLogicNot(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprSizeOf(void* ud, const CompilerLocation* loc, CompilerExpr* operand)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(operand);
    return NULL;
}

static CompilerExpr* exprMultiply(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprDivide(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprModulo(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAdd(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprSubtract(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprShiftLeft(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprShiftRight(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprGreater(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprGreaterEq(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprLess(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprLessEq(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprEqual(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprNotEqual(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprBitwiseAnd(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprBitwiseXor(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprBitwiseOr(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprLogicAnd(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprLogicOr(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprTernary(void* ud, const CompilerLocation* loc,
    CompilerExpr* cond, CompilerExpr* trueValue, CompilerExpr* falseValue)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(cond);
    UNUSED(trueValue);
    UNUSED(falseValue);
    return NULL;
}

static CompilerExpr* exprAssign(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignAdd(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignSub(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignMul(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignDiv(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignMod(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignAnd(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignOr(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignXor(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignShl(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}

static CompilerExpr* exprAssignShr(void* ud, const CompilerLocation* loc, CompilerExpr* op1, CompilerExpr* op2)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(op1);
    UNUSED(op2);
    return NULL;
}


static void stmtEmpty(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtExpr(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtLabel(void* ud, const CompilerLocation* loc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(name);
}

static void stmtGoto(void* ud, const CompilerLocation* loc, const CompilerLocation* nameLoc, const char* name)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(nameLoc);
    UNUSED(name);
}

static void stmtBreak(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtContinue(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtDelete(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtThrow(void* ud, const CompilerLocation* loc, CompilerExpr* optionalExpr)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(optionalExpr);
}

static void stmtCompoundBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtCompoundEnd(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtIfBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtIfThen(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtIfElse(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtIfEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtWhileBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtWhileDo(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtWhileEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtDoBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtDoEnd(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtForBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtForInit(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtForCondition(void* ud, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(e);
}

static void stmtForUpdate(void* ud, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(e);
}

static void stmtForDo(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtForEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtSwitchBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtSwitchOperand(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtSwitchCase(void* ud, const CompilerLocation* loc, CompilerExpr* e)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(e);
}

static void stmtSwitchCaseRange(void* ud, const CompilerLocation* loc, CompilerExpr* start, CompilerExpr* end)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(start);
    UNUSED(end);
}

static void stmtSwitchDefault(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtSwitchEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtTryBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtTry_CatchBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtTry_CatchDo(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtTry_CatchEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtTry_FinallyBegin(void* ud, const CompilerLocation* loc)
{
    UNUSED(ud);
    UNUSED(loc);
}

static void stmtTry_FinallyEnd(void* ud)
{
    UNUSED(ud);
}

static void stmtTryEnd(void* ud)
{
    UNUSED(ud);
}

static void error(void* ud, const CompilerLocation* loc, const CompilerToken* token)
{
    UNUSED(ud);
    UNUSED(loc);
    UNUSED(token);
}

void compilerInitBootstrapCodegen(Compiler* compiler, CompilerParserCallbacks* cb)
{
    Context* context = (Context*)compilerTempAlloc(compiler, sizeof(Context));
    context->compiler = compiler;
    cb->translationUnitBegin = translationUnitBegin;
    cb->translationUnitEnd = translationUnitEnd;
    cb->attrBegin = attrBegin;
    cb->attrParam = attrParam;
    cb->attrEnd = attrEnd;
    cb->attrListBegin = attrListBegin;
    cb->attrListEnd = attrListEnd;
    cb->enumBegin = enumBegin;
    cb->enumType = enumType;
    cb->enumMembersBegin = enumMembersBegin;
    cb->enumMember = enumMember;
    cb->enumMembersEnd = enumMembersEnd;
    cb->enumEnd = enumEnd;
    cb->structBegin = structBegin;
    cb->structParent = structParent;
    cb->structMembersBegin = structMembersBegin;
    cb->structMember = structMember;
    cb->structMembersEnd = structMembersEnd;
    cb->structEnd = structEnd;
    cb->structBegin = structBegin;
    cb->structParent = structParent;
    cb->structMembersBegin = structMembersBegin;
    cb->structMember = structMember;
    cb->structMembersEnd = structMembersEnd;
    cb->structEnd = structEnd;
    cb->classBegin = classBegin;
    cb->classBeginInterface = classBeginInterface;
    cb->classParent = classParent;
    cb->classMembersBegin = classMembersBegin;
    cb->classFriend = classFriend;
    cb->classVariablesBegin = classVariablesBegin;
    cb->classVariablesEnd = classVariablesEnd;
    cb->classDestructorBegin = classDestructorBegin;
    cb->classDestructorEnd = classDestructorEnd;
    cb->classMethodBegin = classMethodBegin;
    cb->classMethodNameSimple = classMethodNameSimple;
    cb->classMethodNameArg = classMethodNameArg;
    cb->classMethodNameEnd = classMethodNameEnd;
    cb->classMethodEnd_Abstract = classMethodEnd_Abstract;
    cb->classMethodBodyBegin = classMethodBodyBegin;
    cb->classMethodEnd = classMethodEnd;
    cb->classMembersEnd = classMembersEnd;
    cb->classEnd = classEnd;
    cb->varDeclBegin = varDeclBegin;
    cb->varBegin = varBegin;
    cb->varType = varType;
    cb->varType_Array = varType_Array;
    cb->varInitializer = varInitializer;
    cb->varEnd = varEnd;
    cb->varDeclEnd = varDeclEnd;
    cb->structInitializerBegin = structInitializerBegin;
    cb->structInitializer = structInitializer;
    cb->structInitializerEnd = structInitializerEnd;
    cb->arrayInitializerBegin = arrayInitializerBegin;
    cb->arrayInitializer = arrayInitializer;
    cb->arrayInitializerEnd = arrayInitializerEnd;
    cb->typeVoid = typeVoid;
    cb->typeBit = typeBit;
    cb->typeBool = typeBool;
    cb->typeInt8 = typeInt8;
    cb->typeUInt8 = typeUInt8;
    cb->typeInt16 = typeInt16;
    cb->typeUInt16 = typeUInt16;
    cb->typeInt32 = typeInt32;
    cb->typeUInt32 = typeUInt32;
    cb->typeObject = typeObject;
    cb->typeIdentifier = typeIdentifier;
    cb->typePointer = typePointer;
    cb->exprNull = exprNull;
    cb->exprFalse = exprFalse;
    cb->exprTrue = exprTrue;
    cb->exprIdentifier = exprIdentifier;
    cb->exprInteger = exprInteger;
    cb->exprParentheses = exprParentheses;
    cb->exprNewBegin = exprNewBegin;
    cb->exprNewEnd_Struct = exprNewEnd_Struct;
    cb->exprNewEnd_Array = exprNewEnd_Array;
    cb->exprMethodCallBegin = exprMethodCallBegin;
    cb->exprMethodSimple = exprMethodSimple;
    cb->exprMethodArg = exprMethodArg;
    cb->exprMethodCallEnd = exprMethodCallEnd;
    cb->exprSubscript = exprSubscript;
    cb->exprMember = exprMember;
    cb->exprPostfixIncr = exprPostfixIncr;
    cb->exprPostfixDecr = exprPostfixDecr;
    cb->exprPrefixIncr = exprPrefixIncr;
    cb->exprPrefixDecr = exprPrefixDecr;
    cb->exprTakeAddress = exprTakeAddress;
    cb->exprDeref = exprDeref;
    cb->exprUnaryPlus = exprUnaryPlus;
    cb->exprUnaryMinus = exprUnaryMinus;
    cb->exprBitwiseNot = exprBitwiseNot;
    cb->exprLogicNot = exprLogicNot;
    cb->exprSizeOf = exprSizeOf;
    cb->exprMultiply = exprMultiply;
    cb->exprDivide = exprDivide;
    cb->exprModulo = exprModulo;
    cb->exprAdd = exprAdd;
    cb->exprSubtract = exprSubtract;
    cb->exprShiftLeft = exprShiftLeft;
    cb->exprShiftRight = exprShiftRight;
    cb->exprGreater = exprGreater;
    cb->exprGreaterEq = exprGreaterEq;
    cb->exprLess = exprLess;
    cb->exprLessEq = exprLessEq;
    cb->exprEqual = exprEqual;
    cb->exprNotEqual = exprNotEqual;
    cb->exprBitwiseAnd = exprBitwiseAnd;
    cb->exprBitwiseXor = exprBitwiseXor;
    cb->exprBitwiseOr = exprBitwiseOr;
    cb->exprLogicAnd = exprLogicAnd;
    cb->exprLogicOr = exprLogicOr;
    cb->exprTernary = exprTernary;
    cb->exprAssign = exprAssign;
    cb->exprAssignAdd = exprAssignAdd;
    cb->exprAssignSub = exprAssignSub;
    cb->exprAssignMul = exprAssignMul;
    cb->exprAssignDiv = exprAssignDiv;
    cb->exprAssignMod = exprAssignMod;
    cb->exprAssignAnd = exprAssignAnd;
    cb->exprAssignOr = exprAssignOr;
    cb->exprAssignXor = exprAssignXor;
    cb->exprAssignShl = exprAssignShl;
    cb->exprAssignShr = exprAssignShr;
    cb->stmtEmpty = stmtEmpty;
    cb->stmtExpr = stmtExpr;
    cb->stmtLabel = stmtLabel;
    cb->stmtGoto = stmtGoto;
    cb->stmtBreak = stmtBreak;
    cb->stmtContinue = stmtContinue;
    cb->stmtDelete = stmtDelete;
    cb->stmtThrow = stmtThrow;
    cb->stmtCompoundBegin = stmtCompoundBegin;
    cb->stmtCompoundEnd = stmtCompoundEnd;
    cb->stmtIfBegin = stmtIfBegin;
    cb->stmtIfThen = stmtIfThen;
    cb->stmtIfElse = stmtIfElse;
    cb->stmtIfEnd = stmtIfEnd;
    cb->stmtWhileBegin = stmtWhileBegin;
    cb->stmtWhileDo = stmtWhileDo;
    cb->stmtWhileEnd = stmtWhileEnd;
    cb->stmtDoBegin = stmtDoBegin;
    cb->stmtDoEnd = stmtDoEnd;
    cb->stmtForBegin = stmtForBegin;
    cb->stmtForInit = stmtForInit;
    cb->stmtForCondition = stmtForCondition;
    cb->stmtForUpdate = stmtForUpdate;
    cb->stmtForDo = stmtForDo;
    cb->stmtForEnd = stmtForEnd;
    cb->stmtSwitchBegin = stmtSwitchBegin;
    cb->stmtSwitchOperand = stmtSwitchOperand;
    cb->stmtSwitchCase = stmtSwitchCase;
    cb->stmtSwitchCaseRange = stmtSwitchCaseRange;
    cb->stmtSwitchDefault = stmtSwitchDefault;
    cb->stmtSwitchEnd = stmtSwitchEnd;
    cb->stmtTryBegin = stmtTryBegin;
    cb->stmtTry_CatchBegin = stmtTry_CatchBegin;
    cb->stmtTry_CatchDo = stmtTry_CatchDo;
    cb->stmtTry_CatchEnd = stmtTry_CatchEnd;
    cb->stmtTry_FinallyBegin = stmtTry_FinallyBegin;
    cb->stmtTry_FinallyEnd = stmtTry_FinallyEnd;
    cb->stmtTryEnd = stmtTryEnd;
    cb->error = error;
}
